<!DOCTYPE html>
<html lang="en">
  <head>
    <title>구조분해할당과 전개연산자</title>
    <script>
      //구조분해할당(비구조화 할당)
      // 1. 배열의 구조할당(=구조분해할당)
      let array1 = [10, 20, 30];
      console.log(array1[0]);

      let [a, b, c] = [10, 20, 30];
      console.log(a); // 10
      console.log(b); // 20
      console.log(c); // 30

      // 전개(spread) 연산자
      let [x, y, ...rest] = [10, 20, 30, 40, 50]; // x=10, y=20, rest(다른이름 해도 됨)=[30, 40, 50]
      console.log(x);
      console.log(y);
      console.log(rest);

      // 값 교환(swap)
      let [i, j] = [10, 20];
      // 임시변수를 만들어 3단계로 교환
      let tmp = i;
      i = j;
      j = tmp;
      // 한줄 표현
      [i, j] = [j, i];
      console.log(i, j); // 10 20 출력

      // KV 객체의 구조분해할당 : 객체는 순번이 없음.
      let obj = {
        apple: 1000,
        banana: 2000,
      };
      let { apple, banana } = obj; // key로 value를 가져오는 것이라 key 이름을 다르게 하면 가져오지 못함
      console.log(apple); // 1000
      console.log(banana); // 2000

      // 새로운 이름으로 할당
      let { apple: f1, banana: f2 } = obj;
      console.log(f1); // 1000
      console.log(f2); // 2000

      // 하나만 가져오기
      let { apple: newFruit } = obj;
      console.log(newFruit); // 1000

      // 전개연산자를 이용한 객체 생성
      let pet = {
        cat: 1000,
        dog: 2000,
        pig: 3000,
      };
      let ball = {
        baseball: 1000,
        soccer: 2000,
        basketball: 3000,
      };
      let favorit = {
        ...pet, // pet의 key-value를 다 가져옴
        ...ball, // ball의 key-value를 다 가져옴
        camping: 4000,
      };
      console.log(favorit); // 6개의 key-value 모두 출력됨

      // 객체 속성 제외
      const { cat, ...rest2 } = pet;
      console.log(cat); // 1000
      console.log(rest2); // {dog:2000, pig:3000}

      // 함수 인자(Argument)/매개변수(Parameter)로 전개연산자 사용
      const nums = [10, 20, 30];
      function sum(x, y, z) {
        return x + y + z;
      }
      //            ...배열이름 : 배열의 모든 요소 나열
      console.log(sum(...nums)); // x=10, y=20, z=30

      // 기본값으로 설정할 때 전개연산자 사용
      const defaultSetting = { theme: "dark", showSidebar: true };
      const userSetting = { showSidebar: false };
      // KV가 겹치면, 뒤에 설정된 것이 사용됨 (overwrite)
      const finalSetting = { ...defaultSetting, ...userSetting };
      console.log(finalSetting); // {theme: 'dark', showSidebar: false}
    </script>
  </head>
  <body></body>
</html>
